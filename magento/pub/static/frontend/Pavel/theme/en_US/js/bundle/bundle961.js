require.config({"config": {
        "jsbuild":{"jquery/ui-modules/position.js":"/*!\n * jQuery UI Position - v1.10.4\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n */\n\ndefine([\n    'jquery'\n], function ($, undefined) {\n\n    $.ui = $.ui || {};\n\n    var cachedScrollbarWidth,\n        max = Math.max,\n        abs = Math.abs,\n        round = Math.round,\n        rhorizontal = /left|center|right/,\n        rvertical = /top|center|bottom/,\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n        rposition = /^\\w+/,\n        rpercent = /%$/,\n        _position = $.fn.position;\n\n    function getOffsets(offsets, width, height) {\n        return [\n            parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),\n            parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)\n        ];\n    }\n\n    function parseCss(element, property) {\n        return parseInt($.css(element, property), 10) || 0;\n    }\n\n    function getDimensions(elem) {\n        var raw = elem[0];\n        if (raw.nodeType === 9) {\n            return {\n                width: elem.width(),\n                height: elem.height(),\n                offset: {top: 0, left: 0}\n            };\n        }\n        if ($.isWindow(raw)) {\n            return {\n                width: elem.width(),\n                height: elem.height(),\n                offset: {top: elem.scrollTop(), left: elem.scrollLeft()}\n            };\n        }\n        if (raw.preventDefault) {\n            return {\n                width: 0,\n                height: 0,\n                offset: {top: raw.pageY, left: raw.pageX}\n            };\n        }\n        return {\n            width: elem.outerWidth(),\n            height: elem.outerHeight(),\n            offset: elem.offset()\n        };\n    }\n\n    $.position = {\n        scrollbarWidth: function () {\n            if (cachedScrollbarWidth !== undefined) {\n                return cachedScrollbarWidth;\n            }\n            var w1, w2,\n                div = $(\"<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\"),\n                innerDiv = div.children()[0];\n\n            $(\"body\").append(div);\n            w1 = innerDiv.offsetWidth;\n            div.css(\"overflow\", \"scroll\");\n\n            w2 = innerDiv.offsetWidth;\n\n            if (w1 === w2) {\n                w2 = div[0].clientWidth;\n            }\n\n            div.remove();\n\n            return (cachedScrollbarWidth = w1 - w2);\n        },\n        getScrollInfo: function (within) {\n            var overflowX = within.isWindow || within.isDocument ? \"\" :\n                within.element.css(\"overflow-x\"),\n                overflowY = within.isWindow || within.isDocument ? \"\" :\n                    within.element.css(\"overflow-y\"),\n                hasOverflowX = overflowX === \"scroll\" ||\n                    (overflowX === \"auto\" && within.width < within.element[0].scrollWidth),\n                hasOverflowY = overflowY === \"scroll\" ||\n                    (overflowY === \"auto\" && within.height < within.element[0].scrollHeight);\n            return {\n                width: hasOverflowY ? $.position.scrollbarWidth() : 0,\n                height: hasOverflowX ? $.position.scrollbarWidth() : 0\n            };\n        },\n        getWithinInfo: function (element) {\n            var withinElement = $(element || window),\n                isWindow = $.isWindow(withinElement[0]),\n                isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;\n            return {\n                element: withinElement,\n                isWindow: isWindow,\n                isDocument: isDocument,\n                offset: withinElement.offset() || {left: 0, top: 0},\n                scrollLeft: withinElement.scrollLeft(),\n                scrollTop: withinElement.scrollTop(),\n                width: isWindow ? withinElement.width() : withinElement.outerWidth(),\n                height: isWindow ? withinElement.height() : withinElement.outerHeight()\n            };\n        }\n    };\n\n    $.fn.position = function (options) {\n        if (!options || !options.of) {\n            return _position.apply(this, arguments);\n        }\n\n        // make a copy, we don't want to modify arguments\n        options = $.extend({}, options);\n\n        var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n            target = $(options.of),\n            within = $.position.getWithinInfo(options.within),\n            scrollInfo = $.position.getScrollInfo(within),\n            collision = (options.collision || \"flip\").split(\" \"),\n            offsets = {};\n\n        dimensions = getDimensions(target);\n        if (target[0].preventDefault) {\n            // force left top to allow flipping\n            options.at = \"left top\";\n        }\n        targetWidth = dimensions.width;\n        targetHeight = dimensions.height;\n        targetOffset = dimensions.offset;\n        // clone to reuse original targetOffset later\n        basePosition = $.extend({}, targetOffset);\n\n        // force my and at to have valid horizontal and vertical positions\n        // if a value is missing or invalid, it will be converted to center\n        $.each([\"my\", \"at\"], function () {\n            var pos = (options[this] || \"\").split(\" \"),\n                horizontalOffset,\n                verticalOffset;\n\n            if (pos.length === 1) {\n                pos = rhorizontal.test(pos[0]) ?\n                    pos.concat([\"center\"]) :\n                    rvertical.test(pos[0]) ?\n                        [\"center\"].concat(pos) :\n                        [\"center\", \"center\"];\n            }\n            pos[0] = rhorizontal.test(pos[0]) ? pos[0] : \"center\";\n            pos[1] = rvertical.test(pos[1]) ? pos[1] : \"center\";\n\n            // calculate offsets\n            horizontalOffset = roffset.exec(pos[0]);\n            verticalOffset = roffset.exec(pos[1]);\n            offsets[this] = [\n                horizontalOffset ? horizontalOffset[0] : 0,\n                verticalOffset ? verticalOffset[0] : 0\n            ];\n\n            // reduce to just the positions without the offsets\n            options[this] = [\n                rposition.exec(pos[0])[0],\n                rposition.exec(pos[1])[0]\n            ];\n        });\n\n        // normalize collision option\n        if (collision.length === 1) {\n            collision[1] = collision[0];\n        }\n\n        if (options.at[0] === \"right\") {\n            basePosition.left += targetWidth;\n        } else if (options.at[0] === \"center\") {\n            basePosition.left += targetWidth / 2;\n        }\n\n        if (options.at[1] === \"bottom\") {\n            basePosition.top += targetHeight;\n        } else if (options.at[1] === \"center\") {\n            basePosition.top += targetHeight / 2;\n        }\n\n        atOffset = getOffsets(offsets.at, targetWidth, targetHeight);\n        basePosition.left += atOffset[0];\n        basePosition.top += atOffset[1];\n\n        return this.each(function () {\n            var collisionPosition, using,\n                elem = $(this),\n                elemWidth = elem.outerWidth(),\n                elemHeight = elem.outerHeight(),\n                marginLeft = parseCss(this, \"marginLeft\"),\n                marginTop = parseCss(this, \"marginTop\"),\n                collisionWidth = elemWidth + marginLeft + parseCss(this, \"marginRight\") + scrollInfo.width,\n                collisionHeight = elemHeight + marginTop + parseCss(this, \"marginBottom\") + scrollInfo.height,\n                position = $.extend({}, basePosition),\n                myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());\n\n            if (options.my[0] === \"right\") {\n                position.left -= elemWidth;\n            } else if (options.my[0] === \"center\") {\n                position.left -= elemWidth / 2;\n            }\n\n            if (options.my[1] === \"bottom\") {\n                position.top -= elemHeight;\n            } else if (options.my[1] === \"center\") {\n                position.top -= elemHeight / 2;\n            }\n\n            position.left += myOffset[0];\n            position.top += myOffset[1];\n\n            // if the browser doesn't support fractions, then round for consistent results\n            if (!$.support.offsetFractions) {\n                position.left = round(position.left);\n                position.top = round(position.top);\n            }\n\n            collisionPosition = {\n                marginLeft: marginLeft,\n                marginTop: marginTop\n            };\n\n            $.each([\"left\", \"top\"], function (i, dir) {\n                if ($.ui.position[collision[i]]) {\n                    $.ui.position[collision[i]][dir](position, {\n                        targetWidth: targetWidth,\n                        targetHeight: targetHeight,\n                        elemWidth: elemWidth,\n                        elemHeight: elemHeight,\n                        collisionPosition: collisionPosition,\n                        collisionWidth: collisionWidth,\n                        collisionHeight: collisionHeight,\n                        offset: [atOffset[0] + myOffset[0], atOffset [1] + myOffset[1]],\n                        my: options.my,\n                        at: options.at,\n                        within: within,\n                        elem: elem\n                    });\n                }\n            });\n\n            if (options.using) {\n                // adds feedback as second argument to using callback, if present\n                using = function (props) {\n                    var left = targetOffset.left - position.left,\n                        right = left + targetWidth - elemWidth,\n                        top = targetOffset.top - position.top,\n                        bottom = top + targetHeight - elemHeight,\n                        feedback = {\n                            target: {\n                                element: target,\n                                left: targetOffset.left,\n                                top: targetOffset.top,\n                                width: targetWidth,\n                                height: targetHeight\n                            },\n                            element: {\n                                element: elem,\n                                left: position.left,\n                                top: position.top,\n                                width: elemWidth,\n                                height: elemHeight\n                            },\n                            horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n                            vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n                        };\n                    if (targetWidth < elemWidth && abs(left + right) < targetWidth) {\n                        feedback.horizontal = \"center\";\n                    }\n                    if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {\n                        feedback.vertical = \"middle\";\n                    }\n                    if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {\n                        feedback.important = \"horizontal\";\n                    } else {\n                        feedback.important = \"vertical\";\n                    }\n                    options.using.call(this, props, feedback);\n                };\n            }\n\n            elem.offset($.extend(position, {using: using}));\n        });\n    };\n\n    $.ui.position = {\n        fit: {\n            left: function (position, data) {\n                var within = data.within,\n                    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n                    outerWidth = within.width,\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n                    overLeft = withinOffset - collisionPosLeft,\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n                    newOverRight;\n\n                // element is wider than within\n                if (data.collisionWidth > outerWidth) {\n                    // element is initially over the left side of within\n                    if (overLeft > 0 && overRight <= 0) {\n                        newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n                        position.left += overLeft - newOverRight;\n                        // element is initially over right side of within\n                    } else if (overRight > 0 && overLeft <= 0) {\n                        position.left = withinOffset;\n                        // element is initially over both left and right sides of within\n                    } else {\n                        if (overLeft > overRight) {\n                            position.left = withinOffset + outerWidth - data.collisionWidth;\n                        } else {\n                            position.left = withinOffset;\n                        }\n                    }\n                    // too far left -> align with left edge\n                } else if (overLeft > 0) {\n                    position.left += overLeft;\n                    // too far right -> align with right edge\n                } else if (overRight > 0) {\n                    position.left -= overRight;\n                    // adjust based on position and margin\n                } else {\n                    position.left = max(position.left - collisionPosLeft, position.left);\n                }\n            },\n            top: function (position, data) {\n                var within = data.within,\n                    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n                    outerHeight = data.within.height,\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\n                    overTop = withinOffset - collisionPosTop,\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n                    newOverBottom;\n\n                // element is taller than within\n                if (data.collisionHeight > outerHeight) {\n                    // element is initially over the top of within\n                    if (overTop > 0 && overBottom <= 0) {\n                        newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n                        position.top += overTop - newOverBottom;\n                        // element is initially over bottom of within\n                    } else if (overBottom > 0 && overTop <= 0) {\n                        position.top = withinOffset;\n                        // element is initially over both top and bottom of within\n                    } else {\n                        if (overTop > overBottom) {\n                            position.top = withinOffset + outerHeight - data.collisionHeight;\n                        } else {\n                            position.top = withinOffset;\n                        }\n                    }\n                    // too far up -> align with top\n                } else if (overTop > 0) {\n                    position.top += overTop;\n                    // too far down -> align with bottom edge\n                } else if (overBottom > 0) {\n                    position.top -= overBottom;\n                    // adjust based on position and margin\n                } else {\n                    position.top = max(position.top - collisionPosTop, position.top);\n                }\n            }\n        },\n        flip: {\n            left: function (position, data) {\n                var within = data.within,\n                    withinOffset = within.offset.left + within.scrollLeft,\n                    outerWidth = within.width,\n                    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n                    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n                    overLeft = collisionPosLeft - offsetLeft,\n                    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n                    myOffset = data.my[0] === \"left\" ?\n                        -data.elemWidth :\n                        data.my[0] === \"right\" ?\n                            data.elemWidth :\n                            0,\n                    atOffset = data.at[0] === \"left\" ?\n                        data.targetWidth :\n                        data.at[0] === \"right\" ?\n                            -data.targetWidth :\n                            0,\n                    offset = -2 * data.offset[0],\n                    newOverRight,\n                    newOverLeft;\n\n                if (overLeft < 0) {\n                    newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n                    if (newOverRight < 0 || newOverRight < abs(overLeft)) {\n                        position.left += myOffset + atOffset + offset;\n                    }\n                } else if (overRight > 0) {\n                    newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n                    if (newOverLeft > 0 || abs(newOverLeft) < overRight) {\n                        position.left += myOffset + atOffset + offset;\n                    }\n                }\n            },\n            top: function (position, data) {\n                var within = data.within,\n                    withinOffset = within.offset.top + within.scrollTop,\n                    outerHeight = within.height,\n                    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n                    collisionPosTop = position.top - data.collisionPosition.marginTop,\n                    overTop = collisionPosTop - offsetTop,\n                    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n                    top = data.my[1] === \"top\",\n                    myOffset = top ?\n                        -data.elemHeight :\n                        data.my[1] === \"bottom\" ?\n                            data.elemHeight :\n                            0,\n                    atOffset = data.at[1] === \"top\" ?\n                        data.targetHeight :\n                        data.at[1] === \"bottom\" ?\n                            -data.targetHeight :\n                            0,\n                    offset = -2 * data.offset[1],\n                    newOverTop,\n                    newOverBottom;\n                if (overTop < 0) {\n                    newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n                    if ((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {\n                        position.top += myOffset + atOffset + offset;\n                    }\n                } else if (overBottom > 0) {\n                    newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n                    if ((position.top + myOffset + atOffset + offset) > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {\n                        position.top += myOffset + atOffset + offset;\n                    }\n                }\n            }\n        },\n        flipfit: {\n            left: function () {\n                $.ui.position.flip.left.apply(this, arguments);\n                $.ui.position.fit.left.apply(this, arguments);\n            },\n            top: function () {\n                $.ui.position.flip.top.apply(this, arguments);\n                $.ui.position.fit.top.apply(this, arguments);\n            }\n        }\n    };\n\n// fraction support test\n    (function () {\n        var testElement, testElementParent, testElementStyle, offsetLeft, i,\n            body = document.getElementsByTagName(\"body\")[0],\n            div = document.createElement(\"div\");\n\n        //Create a \"fake body\" for testing based on method used in jQuery.support\n        testElement = document.createElement(body ? \"div\" : \"body\");\n        testElementStyle = {\n            visibility: \"hidden\",\n            width: 0,\n            height: 0,\n            border: 0,\n            margin: 0,\n            background: \"none\"\n        };\n        if (body) {\n            $.extend(testElementStyle, {\n                position: \"absolute\",\n                left: \"-1000px\",\n                top: \"-1000px\"\n            });\n        }\n        for (i in testElementStyle) {\n            testElement.style[i] = testElementStyle[i];\n        }\n        testElement.appendChild(div);\n        testElementParent = body || document.documentElement;\n        testElementParent.insertBefore(testElement, testElementParent.firstChild);\n\n        div.style.cssText = \"position: absolute; left: 10.7432222px;\";\n\n        offsetLeft = $(div).offset().left;\n        $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;\n\n        testElement.innerHTML = \"\";\n        testElementParent.removeChild(testElement);\n    })();\n\n});\n"}
}});
